Tekstidentificatie Verslag

De Tekstidentificatie programma maakt gebruik van de class 'TextModel' om drie objecten aan te maken: 'tm_unknown', 'tm_model1' en 'tm_model2'. Daarna wordt het bestand 'train1.txt' gelezen met de functie 'read_text_from_file' voor 'tm_model1' en het bestand 'train2.txt' gelezen voor 'tm_model2'. Voor 'tm_unknown' wordt het bestand 'unknown.txt' gelezen met dezelfde functie. Vervolgens worden dictionaries gegenereerd met de functie 'create_all_dictionaries' voor de drie modellen.
Om de resultaten overzichtelijker te maken, geef ik elk model een naam voor weergave: 'tm_model1.model1_info = {naam: "De naam van model1"}'.
Daarna vergelijkt de methode 'compare_text_with_two_models' de kenmerken (woorden, woordlengtes, stammen, zinslengtes, interpunctie, g-woorden) van de drie objecten (self, model1, model2) door middel van de 'compare_dictionaries' functie.
def make_g_woorden mijn eigen bedachte eigenschap. In de milestone De methode make_g_woorden telt het aantal keren dat de letter 'g' in een tekst voorkomt. De methode neemt een tekst als invoer, reinigt deze eerst van interpunctie en andere niet-lettertekens en telt vervolgens elke instantie van de letter 'g'. De resultaten van de telling worden opgeslagen in een woordenboek genaamd 'g_woorden'. In oplevring.py heb ik de methode verbeterd door alle woorden die beginnen met de letter 'g' te tellen. En In plaats van een list comprehension heb ik een for loop gebruikt. 
De methode 'compare_dictionaries' vergelijkt twee genormaliseerde verzamelingen (nd1 en nd2) met een andere verzameling van gegevens (d) door gebruik te maken van de methode 'normalize_dictionary'.
'normalize_dictionary(self, d)' normaliseert een verzameling van gegevens door de som van alle waardes te berekenen en deze waardes vervolgens te delen door de som. Hierdoor wordt de som van alle waardes 1.0 en is de geretourneerde verzameling genormaliseerd.
Vervolgens vergelijkt 'compare_dictionaries' de logaritmische waarden van elke sleutel in de verzameling van gegevens (d) met de waarden in de twee genormaliseerde verzamelingen. Als een sleutel niet aanwezig is in één van de genormaliseerde verzamelingen, wordt een epsilon waarde gebruikt. De methode geeft vervolgens de totale waarden van de vergelijkingen voor beide genormaliseerde verzamelingen terug.
Voor elke feature wordt de vergelijking gemaakt door 'compare_dictionaries' te gebruiken met de respectieve dictionaries als argumenten. De resultaten van de vergelijkingen worden toegevoegd aan de lijst 'dictionaries' als een lijst van lijsten, waar elke lijst bevat: de naam van de feature en het resultaat van de verschillende features worden afgerond tot twee decimalen vervolgens geprint.
De winnaar wordt bepaald door wie het meeste punten heeft van  "model1_wins" of  "model2_wins". Als model1 het grootste aantal bezit voor een bepaald feature, krijgt model1 +1 aan "model1_wins". Anders krijgt model2 +1 aan "model2_wins". De model met de meeste "wins" wordt uiteindelijk bepaald als de winnaar.
Als er geen duidelijke winnaar is, dan worden de verschillende feature apart bekeken en wordt het model bepaald op basis van de meeste overeenkomsten met het te vergelijken object (self).

